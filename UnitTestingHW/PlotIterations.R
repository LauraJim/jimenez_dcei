# DESCRIPTION:
# Generates a visualization of the results from the function Runtwalk that
# to simulate from the posterior of mu and A.
# Plot environmental space (2 dimensions) using the background points
# selected for the species together with the occurrence points and
# the ellipses that were generated by the MCMC algorithm (and that
# represent a sample from the posterior distribution).

# ARGUMENTS: see NOTES
# th --- vector that contains the current values of parameters mu and A
# info --- the output of the function Runtwalk from the package Rtwalk
#         (a matrix with all the simulated values of mu and A from the posterior distribution)
# env.d --- a matrix with as many columns as axes in environmental space whose rows are existing climatic conditions
# env.sp --- a matrix with as many columns as axes in environmental space whose rows are the environmental conditions from occurrence points
# from --- a number that indicates the start point to choose from info (burn-in time)
# thin --- a number equals to number of values to skip before selecting the next values from info
# col --- character vector definig the colors of [1] the background and [2] the occurrence points
# lev --- a value in (0,1) indicating the confidence level that the ellipses represent in the MVN distribution
# ... --- any other parameter that can be used by the functions plot, lines, points

# OUTPUTS: see NOTES
# A plot that shows the environmental background, the occurrence points and
# a sample of ellipses from the posterior distribution with different colors.

# NOTES:
# The global variables mu and A are implicitly used

# CODE:
PlotIterations <- function(info, env.d, env.sp, from=2000, thin=200, lev=0.95, cols=c("gray","orange","blue"), ...)
{
  # calculate the value of the posterior distribution for each row of info
  post <- exp(-info$Us - max(-info$Us) + 500)/exp(500) ## This is a normalized posterior from 0 to 1
  # find the MAP and print it
  ix <- which.max(post)[1]
  (map <- info$output[ix,])
  # plot background and occurrence points
  plot(env.d, pch=".", col=cols[1], ...)
  points(env.sp, pch=19, col=cols[2])
  # create a vector of indices to choose from the simulated values of the posterior
  indices <- seq(from, info$Tr, thin)
  # plot all the ellipses using a different color according to their posterior value
  for (i in indices) 
  {
    if(Supp(info$output[i,])) # each time check if the values are valid
    {
      el<-ellipse::ellipse(x=chol2inv(chol(A)),centre = mu,level=lev) 
      lines(el,col=grey(1-post[i]),lwd=2) 
    }
  }
  if (!(is.null(map)))
    if(Supp(map)) ## after this step we kept the MAP in the variables mu and A
    {
      el<-ellipse::ellipse(x=chol2inv(chol(A)),centre = mu,level=lev) 
      lines(el,col=cols[3],lwd=3)
    }
}
